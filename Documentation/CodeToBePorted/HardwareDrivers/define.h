#ifndef	DEFINE_H
#define	DEFINE_H

#include "types.h"
#include "e2prom.h"
#include "user_data.h"
#include "commsub.h"
#include "product.h"
#include "bacnet.h"



#define CRC_YES 1
#define CRC_NO 0

//#define BIG	1
//#define SMALL 2
//#define TINY 3
//#define VAV 4

#define READ_VARIABLES      3
#define WRITE_VARIABLES     6
#define MULTIPLE_WRITE		16
#define CHECKONLINE			0x19
#define CHECKONLINE_WIHTCOM	 0x18

#define DATABUFLEN			137

#define ORIGINALADDRESSVALUE	100
#define CALIBRATION_OFFSET    128 //allows us to store FLASH_CALIBRATION as an U18_T

// 199 is the highest address we can use when storing variables in the flash memory
#define 	EEP_SERINALNUMBER_WRITE_FLAG	199 
#define 	TOTAL_EE_PARAMETERS		208
 
#define DHCP   1
#define STATIC 0

#define HI_COMMON_CHANNEL  32

typedef	enum
{
	NOUSE = 0,MAIN_MSTP,SUB_MODBUS,PTP_RS232_GSM,SUB_GSM,MAIN_ZIG,SUB_ZIG,MASTER_MODBUS,RS232_METER,
//	TEST_SUB_MODBUS = 20,
//	TEST_MASTER_MODBUS = 21,
	MAX_COM_TYPE
};


#if MINI
typedef struct 
{
	uint16_t baut;
	uint8_t type;
	uint8_t len;
	uint8_t cmd[10];
	uint32_t res;
}RS232_CMD;
extern RS232_CMD rs232_cmd;
void send_rs232_command(void);
#endif

#define BAC_MSTP 0
#define BAC_IP 1


//#define MODBUS 0 
//#define TCP_IP 1
//#define BAC_MSTP 2
//#define BAC_IP 3
//#define BAC_PTP 4
#define BAC_GSM 2

#define WR_DESCRIPTION_SIZE			31
#define AR_DESCRIPTION_SIZE			29
#define ID_SIZE						3
#define AR_TIME_SIZE				46
#define WR_TIME_SIZE			    72
#define SCH_TIME_SIZE				1


#define PRODUCT_CM5		50
#define PRODUCT_MINI_BIG	35
#define PRODUCT_MINI_SMALL	35
#define PRODUCT_MINI_TINY	35
#define PRODUCT_MINI_VAV	35

#define PRODUCT_VAV   35

typedef struct
{
	U8_T serialNum[4];
	U8_T address; 	
	U8_T protocal;
	U8_T product_model;
	U8_T hardRev;
	U8_T baudrate;
	U8_T unit;
//	U8_T switch_tstat_val;
	U8_T IspVer;
	U8_T PicVer;
	U8_T update_status;
	U8_T  base_addr;
	U8_T  tcp_type;   /* 0 -- DHCP, 1-- STATIC */
	U8_T  ip_addr[4];
	U8_T  mac_addr[6];
	U8_T  	subnet[4];
	U8_T  	getway[4];
	U16_T 	tcp_port;
	U8_T  mini_type;
	U8_T  sub_port;
//	U8_T zigbee_or_gsm;
	U8_T point_sequence;
	U8_T main_port;
	U8_T external_nodes_plug_and_play;
	U8_T com_config[3];
	U16_T start_adc[11];
	U8_T refresh_flash_timer;

	U8_T network_number;
	U8_T  en_username;
	U8_T  cus_unit;

	U8_T  usb_mode;
	U8_T en_dyndns;
	U8_T en_sntp;	

}STR_MODBUS;

// define AVS 
//typedef union
//{
//	U16_T avs[50];
//	struct
//	{
//	U16_T avs_num;
////	U16_T serialNum[4];
//	U16_T address; 
////	U16_T product_model;
//	U16_T hardRev;
//	U16_T firwareRev;
////	U16_T baudrate;
//	U16_T tcp_type;   /* 0 -- DHCP, 1-- STATIC */
//	U16_T ip_addr[4];
//	U16_T mac_addr[6];
//	U16_T subnet[4];
//	U16_T getway[4];
//	U16_T tcp_port;
////	U16_T mini_type;
//	U16_T com_config[3];
//	U16_T com_baudrate[3];
////	U16_T start_adc[11];
////	U16_T refresh_flash_timer;
//	U16_T network_number;
//  U16_T panel_number;
//	}reg;
//}STR_BACNET_AV;




extern U8_T uart0_baudrate;
extern U8_T uart1_baudrate;
extern U8_T uart2_baudrate;

extern	U8_T far bbmd_en;
extern	U16_T far mstp_network;

//typedef union
//{
//	unsigned char byte[4];
//	unsigned long longbyte;
//
//}UN_HIGH_COUNT;
//
//extern UN_HIGH_COUNT high_spd_counter[HI_COMMON_CHANNEL];
extern U32_T high_spd_counter[HI_COMMON_CHANNEL];
extern U32_T high_spd_counter_tempbuf[HI_COMMON_CHANNEL];
extern U8_T high_spd_en[HI_COMMON_CHANNEL];
typedef	union
{
	unsigned int  word;
	unsigned char byte[2];
}UN_RELAY;

	 
extern UN_Time far update_dyndns_time;
extern UN_Time RTC;
extern U16_T input_raw[MAX_INS];
extern U16_T input_raw_back[MAX_INS];
extern U16_T output_raw[MAX_OUTS];
extern U16_T output_raw_back[MAX_OUTS];
extern U8_T subnet_rec_package_size;
extern U8_T max_dos;

extern U16_T chip_info[6];
extern U8_T high_spd_flag[HI_COMMON_CHANNEL];
extern U8_T clear_high_spd[HI_COMMON_CHANNEL];
extern U8_T InputLed[32];
extern U8_T far input_type[32];
extern U8_T far input_type1[32];
	
extern STR_MODBUS  far Modbus;
extern U16_T count_flash;



extern bit flag_logic_control;
extern U8_T flag_output_control;
extern UN_RELAY relay_value;
extern U8_T far flag_output;



extern S16_T far timezone;
extern U8_T far SntpServer[4];


extern U8_T flag_Update_Sntp;
extern U8_T Update_Sntp_Retry;


#define BASE_ADDR   0x30 


															   
#if CM5
#define HW_REV	8
#endif



#define PIC_REV 0x01  // pic688


#define CM5_ADDRESS 254
#define PRODUCT_MODEL	50


typedef enum
{
 	UART_1200 = 0,
	UART_2400,
	UART_3600,
	UART_4800,
	UART_7200,
	UART_9600,
	UART_19200,
	UART_38400,
	UART_57600,
	//UART_76800,
	UART_115200,
	UART_921600,
	UART_BAUDRATE_MAX

}E_BAUD;
// define flash address

typedef enum{
	//EEP_IP = 0x19
	EEP_MAC = 0x06,	  // 6 bytes 0x06 - 0x0b
	EEP_IP = 0x19,  // 4 bytes	  0x19 - 0x1c
	EEP_SUBNET = 0x1d, // 4 bytes  0x1d - 0x20
//--- other thing
	EEP_SERIALNUMBER_LOWORD = 0 + USER_BASE_ADDR,             
	EEP_SERIALNUMBER_HIWORD = 2 + USER_BASE_ADDR,
	EEP_NO_USED1,  // NO USED
	EEP_DYNDNS_PROVIDER, 
	EEP_ADDRESS						= 6 + USER_BASE_ADDR,
	EEP_EN_SNTP,   
	EEP_HARDWARE_REV,
 	EEP_UART0_BAUDRATE,				//	63
	EEP_EN_DYNDNS,     
  EEP_ADDRESS_PLUG_N_PLAY ,
	EEP_TIME_ZONE_HI,    
	EEP_TIME_ZONE_LO,  
	EEP_TCP_TYPE,
	EEP_MINI_TYPE,
	EEP_GETWAY = 16 + USER_BASE_ADDR,  // 4 bytes
	
	EEP_NETWORK = 20 + USER_BASE_ADDR,
	EEP_MSTP_NETWORK_HI,
	EEP_MSTP_NETWORK_LO,
	EEP_BBMD_EN,
	
	EEP_ETR_REBOOT,
	EEP_NO_USED7 = 25 + USER_BASE_ADDR, // NO USED
	EEP_NO_USED19 = 26 + USER_BASE_ADDR,  // NO USED
	
	EEP_DYNDNS_UPDATE_LO,  // 20
	EEP_DYNDNS_UPDATE_HI,

	EEP_COM0_CONFIG = 29 + USER_BASE_ADDR,
  EEP_COM1_CONFIG,
	EEP_COM2_CONFIG,
	EEP_EN_NODE_PLUG_N_PLAY,
	EEP_OUTPUT_MODE,//EEP_NO_USED20,  // NO USED 33
	EEP_REFRESH_FLASH,
   	
	EEP_OUT_1V,
	EEP_OUT_2V,
	EEP_OUT_3V,
	EEP_OUT_4V,
	EEP_OUT_5V,
	EEP_OUT_6V,
	EEP_OUT_7V,
	EEP_OUT_8V,
	EEP_OUT_9V,
	EEP_OUT_10V,

	EEP_NO_USED21 = 45 + USER_BASE_ADDR, // NO USED
	EEP_NO_USED26 = 50 + USER_BASE_ADDR, // NO USED

	EEP_UART1_BAUDRATE,
	EEP_UART2_BAUDRATE,
	
	EEP_SD_BLOCK_A1 = 53 + USER_BASE_ADDR,
	EEP_SD_BLOCK_A12 = 75 + USER_BASE_ADDR,
	EEP_SD_BLOCK_D1 = 77 + USER_BASE_ADDR,
	EEP_SD_BLOCK_D12 = 99 + USER_BASE_ADDR,	
	
	EEP_NO_USED27 = 101 + USER_BASE_ADDR, // NO USED
	EEP_NO_USED71 = 145 + USER_BASE_ADDR, // NO USED


	EEP_SWITCH = 146 + USER_BASE_ADDR, 
	EEP_GSM_SEVER_OR_CLIENT,

	EEP_GSM_IP1,
	EEP_GSM_IP2,
	EEP_GSM_IP3,
	EEP_GSM_IP4,
	EEP_GSM_TCP_PORT_LO,
	EEP_GSM_TCP_PORT_HI,

	EEP_USER_NAME,  
	EEP_CUS_UNIT,  
	EEP_USB_MODE,	   
	EEP_STATION_NUM,	  

	



	EEP_SERIALNUMBER_WRITE_FLAG,

	EEP_SNTP_SERVER1,	
	EEP_SNTP_SERVER2,
	EEP_SNTP_SERVER3,
	EEP_SNTP_SERVER4,    
	EEP_NO_USED72 = 163 + USER_BASE_ADDR, // NO USED
	EEP_NO_USED79 = 170 + USER_BASE_ADDR, // NO USED

	EEP_PORT_LOW = 171 + USER_BASE_ADDR,
	EEP_PORT_HIGH,

	EEP_NO_USED80 = 173 + USER_BASE_ADDR, // NO USED
	EEP_NO_USED114 = 207 + USER_BASE_ADDR, // NO USED

	MAX_EEP_CONSTRANGE = 255,
}E_EEP;


#define SCHEDUAL_MODBUS_ADDRESS		200

typedef enum {

	MODBUS_SERIALNUMBER_LOWORD = 0,             
	MODBUS_SERIALNUMBER_HIWORD	= 2,
	MODBUS_FIRMWARE_VERSION_NUMBER_LO   	= 4  ,
	MODBUS_FIRMWARE_VERSION_NUMBER_HI,
	MODBUS_ADDRESS					= 6,
	MODBUS_PRODUCT_MODEL,  // 7
	MODBUS_HARDWARE_REV,  // 8

 	
//	MODBUS_INIT_WR_TIME, 
	MODBUS_PIC = 9,
  MODBUS_ADDRESS_PLUG_N_PLAY= 10,
	MODBUS_TIME_ZONE = 11,	

	MODBUS_UART0_BAUDRATE,   // for uart0
	MODBUS_EN_NODES_PLUG_N_PLAY,//	 	nodes_plug_and_play
//	MODBUS_DAYLIGHT_ENABLE,
//	MODBUS_DAYLIGHT_STATUS,
//	MODBUS_RESET_FLASH,	
	MODBUS_ISP_VER = 14,
// registers needed for updating status
	MODBUS_UPDATE_STATUS = 16,	
	MODBUS_UNIT =17,
	MODBUS_UART1_BAUDRATE,
	MODBUS_UART2_BAUDRATE,

	MODBUS_SNTP_SERVER1,  // 20
	MODBUS_SNTP_SERVER2,
	MODBUS_SNTP_SERVER3,
	MODBUS_SNTP_SERVER4,
	MODBUS_SNTP_TIMEZONE, // 24
	MODBUS_SNTP_EN,		//  25

	MODBUS_PROTOCAL = 32, // no used
	MODBUS_TEST_CMD = 33,
	MODBUS_MINI_TYPE,
	MODBUS_INSTANCE,
	MODBUS_STATION_NUM,
	MODBUS_SUB_PORT, // no used
	MODBUS_ZIGBEE_EN, // no used
	MODBUS_CLEAR_SCAN_DB = 39, // no used
	MODBUS_EN_USER,  
	MODBUS_EN_CUS_UNIT,

	MODBUS_USB_MODE,  // no used
	MODBUS_EN_DYNDNS,  // 43
	MODBUS_DYNDNS_PROVIDER,// 44
	MODBUS_DYNDNS_UPDATE,// 45
	MODBUS_NETWORK,  // 46
	MODBUS_MSTP_NETWORK, // 47
	MODBUS_BBMD_EN,  // 48
	
// FOR SEAN  
	MODBUS_PIC_WATCHDOG = 50,

	MODBUS_CHIP1_HW,  // PIC
	MODBUS_CHIP2_HW,  // C8051F023
	MODBUS_CHIP3_HW,  // LED
	MODBUS_CHIP4_HW,  // SWITCH
	MODBUS_CHIP1_SW,   
	MODBUS_CHIP2_SW,
	MODBUS_CHIP3_SW,
	MODBUS_CHIP4_SW,

  MODBUS_COM0_TYPE = 59,
	MODBUS_COM1_TYPE,
	MODBUS_COM2_TYPE,

	MODBUS_REFRESH_FLASH,

	MODBUS_OUTPUT_1V = 70, 
	MODBUS_OUTPUT_2V,
	MODBUS_OUTPUT_3V,
	MODBUS_OUTPUT_4V,
	MODBUS_OUTPUT_5V,
	MODBUS_OUTPUT_6V,
	MODBUS_OUTPUT_7V,
	MODBUS_OUTPUT_8V,
	MODBUS_OUTPUT_9V,
	MODBUS_OUTPUT_10V,
	MODBUS_OUTPUT_TEST_VALUE = 80,
	MODBUS_OUTPUT_TEST_FLAG,
	MODBUS_OUTPUT_MODE,  // AUTO - 1 OR STATIC - 0

	MODBUS_ENABLE_WRITE_MAC = 93,

	/* 100 ~ 133 */
   	MODBUS_MAC_1 = 100,
	MODBUS_MAC_2,
	MODBUS_MAC_3,
	MODBUS_MAC_4,
	MODBUS_MAC_5,
	MODBUS_MAC_6,

	MODBUS_TCP_TYPE = 106,	  // DHCP OR STATIC

	MODBUS_IP_1,	  // IP have 4 bytes
	MODBUS_IP_2,
	MODBUS_IP_3,
	MODBUS_IP_4,

	MODBUS_SUBNET_1,	  // subnet have 4 bytes
	MODBUS_SUBNET_2,
	MODBUS_SUBNET_3,
	MODBUS_SUBNET_4,

	MODBUS_GETWAY_1,	  // getway have 4 bytes
	MODBUS_GETWAY_2,
	MODBUS_GETWAY_3,
	MODBUS_GETWAY_4,

	MODBUS_TCPSERVER,		// no used
	MODBUS_TCP_LISTEN_PORT,	

	MODBUS_GSM_IP_1,
	MODBUS_GSM_IP_2,
	MODBUS_GSM_IP_3,
	MODBUS_GSM_IP_4,
	MODBUS_GSM_TCPPORT,
	MODBUS_GSM_SEVER_OR_CLIENT,
//	MODBUS_GSM_UDPPORT,
//	MODBUS_GSM_TCP_LINKID,
//	MODBUS_GSM_UDP_LINKID,

	MODBUS_RESERVED_EN = 149,  // 78
  MODBUS_RESERVED1 = 150,  // VAR1
	MODBUS_RESERVED2 = 151,  // VAR2
	

	MODBUS_TIMER_ADDRESS = SCHEDUAL_MODBUS_ADDRESS, // 200
	
	MODBUS_CUSTOMER_DEVICE = 280,

	MODBUS_ADD_ID_BY_HAND = 298 ,
	MODBUS_TOTAL_NO = 299  ,  // NUMBER OF ZONES

	MODBUS_SUBADDR_FIRST = 300 ,	// 193
	MODBUS_SUBADDR_LAST = 400 , // 200

#if BAC_COMMON

	MODBUS_MAX_AV = 500,
	MODBUS_MAX_AI,
	MODBUS_MAX_AO,
	MODBUS_MAX_BI,
	MODBUS_MAX_BO,

	MODBUS_AV_FIRST = 510,
	MODBUS_AV_LAST = MODBUS_AV_FIRST + MAX_AVS - 1,
	MODBUS_AI_FIRST,  // 542
	MODBUS_AI_LAST = MODBUS_AI_FIRST + MAX_AIS - 1,
	MODBUS_AO_FIRST,  // 574
	MODBUS_AO_LAST = MODBUS_AO_FIRST + MAX_AOS - 1,
	MODBUS_BI_FIRST,  // 586
	MODBUS_BI_LAST = MODBUS_BI_FIRST + MAX_BIS - 1,
	MODBUS_BO_FIRST,   // 591
	MODBUS_BO_LAST = MODBUS_BO_FIRST + MAX_BOS - 1,
#endif

//  SD BLOCK
	MODBUS_SD_BLOCK_A1 = 6000,  // 6000
  MODBUS_SD_BLOCK_A12 = 6011,
	MODBUS_SD_BLOCK_D1 = 6012,  // 6000
  MODBUS_SD_BLOCK_D12 = 6023,

	MODBUS_TEST = 7000,
	MODBUS_TEST_50 = 7099,

	MODBUS_OUT_NUM = 8000,
	MODBUS_IN_NUM = 8001,
	MODBUS_VAR_NUM = 8002,
	MODBUS_CON_NUM = 8003,
	MODBUS_WR_NUM = 8004,
	MODBUS_AR_NUM = 8005,
	MODBUS_PRG_NUM = 8006,
	MODBUS_TBL_NUM = 8007,
	MODBUS_TZ_NUM = 8008,
	MODBUS_AMON_NUM = 8009,
	MODBUS_GRP_NUM = 8010,
	MODBUS_ARRAY_NUM = 8011,
	MODBUS_ALARM_NUM = 8012,
	MODBUS_UNIT_NUM = 8013,
	MODBUS_USER_NAME_NUM = 8014,
	MODBUS_ALARM_SET_NUM = 8015,
	MODBUS_SUB_NO,
//	MODBUS_SEQUENCE,  // there are 2 ways to list INPUT struct 0 -- same as T3-4AO  1 - same as bacnet point packet

	MODBUS_OUTPUT_FIRST = 8020,
	MODBUS_OUTPUT_LAST = MODBUS_OUTPUT_FIRST + MAX_OUTS - 1,

	MODBUS_OUTPUT_SWICH_FIRST ,	// 8084
	MODBUS_OUTPUT_SWICH_LAST = MODBUS_OUTPUT_SWICH_FIRST + MAX_OUTS - 1,

	MODBUS_OUTPUT_RANGE_FIRST,  // 8148
	MODBUS_OUTPUT_RANGE_LAST = MODBUS_OUTPUT_RANGE_FIRST + MAX_OUTS - 1,

	MODBUS_OUTPUT_AM_FIRST,  // 8212
	MODBUS_OUTPUT_AM_LAST = MODBUS_OUTPUT_AM_FIRST + MAX_OUTS - 1,

	MODBUS_OUTPUT_AD_FIRST,  // 8276  ANALOG OR DIGITAL
	MODBUS_OUTPUT_AD_LAST = MODBUS_OUTPUT_AD_FIRST + MAX_OUTS - 1,


	MODBUS_INPUT_FIRST,	  // 8340
	MODBUS_INPUT_LAST = MODBUS_INPUT_FIRST + MAX_INS - 1,

	MODBUS_INPUT_FILTER_FIRST,	// 8404
	MODBUS_INPUT_FILTER_LAST = MODBUS_INPUT_FILTER_FIRST + MAX_OUTS - 1,

	MODBUS_INPUT_CAL_FIRST,	  // 8468
	MODBUS_INPUT_CAL_LAST = MODBUS_INPUT_CAL_FIRST + MAX_INS - 1,

	MODBUS_INPUT_CAL_SIGN_FIRST,  // 8532
	MODBUS_INPUT_CAL_SIGN_LAST =  MODBUS_INPUT_CAL_SIGN_FIRST + MAX_INS - 1, 

	MODBUS_INPUT_RANGE_FIRST,	  // 8596
	MODBUS_INPUT_RANGE_LAST = MODBUS_INPUT_RANGE_FIRST + MAX_INS - 1,

  MODBUS_INPUT_HI_SPD_COUNTER_FIRST,	  // 8660
	MODBUS_INPUT_HI_SPD_COUNTER_LAST = MODBUS_INPUT_HI_SPD_COUNTER_FIRST + HI_COMMON_CHANNEL * 2 - 1,

	MODBUS_INPUT_HI_SPD_EN_FIRST, //8672
	MODBUS_INPUT_HI_SPD_EN_LAST = MODBUS_INPUT_HI_SPD_EN_FIRST + HI_COMMON_CHANNEL - 1,

	MODBUS_INPUT_TYPE_FIRST, // 8678
	MODBUS_INPUT_TYPE_LAST = MODBUS_INPUT_TYPE_FIRST + MAX_INS - 1,

	MODBUS_VAR_FIRST, // 8820
	MODBUS_VAR_LAST = MODBUS_VAR_FIRST + MAX_VARS - 1,,
	
	MODBUS_VAR_AM_FIRST,  // 8820+128
	MODBUS_VAR_AM_LAST = MODBUS_VAR_AM_FIRST + MAX_VARS - 1,
	
	
	MODBUS_SETTING_BLOCK_FIRST = 9800,
	MODBUS_USER_BLOCK_FIRST = MODBUS_SETTING_BLOCK_FIRST,
	
	MODBUS_SETTING_BLOCK_LAST = 9999,
	
	MODBUS_OUTPUT_BLOCK_FIRST = 10000,      
	MODBUS_OUTPUT_BLOCK_LAST = MODBUS_OUTPUT_BLOCK_FIRST + MAX_OUTS * ((sizeof(Str_out_point) + 1)/ 2) - 1,
	
	MODBUS_INPUT_BLOCK_FIRST,
	MODBUS_INPUT_BLOCK_LAST = MODBUS_INPUT_BLOCK_FIRST + MAX_INS * ((sizeof(Str_in_point) + 1) / 2) - 1,

	MODBUS_VAR_BLOCK_FIRST,
	MODBUS_VAR_BLOCK_LAST = MODBUS_VAR_BLOCK_FIRST + MAX_VARS * ((sizeof(Str_variable_point) + 1) / 2) - 1,
	
	MODBUS_PRG_BLOCK_FIRST,
	MODBUS_PRG_BLOCK_LAST = MODBUS_PRG_BLOCK_FIRST + MAX_PRGS * ((sizeof(Str_program_point) + 1) / 2) - 1,
		
	MODBUS_WR_BLOCK_FIRST,
	MODBUS_WR_BLOCK_LAST = MODBUS_WR_BLOCK_FIRST + MAX_WR * ((sizeof(Str_weekly_routine_point) + 1) / 2) - 1,
		
	MODBUS_AR_BLOCK_FIRST,
	MODBUS_AR_BLOCK_LAST = MODBUS_AR_BLOCK_FIRST + MAX_AR * ((sizeof(Str_annual_routine_point) + 1) / 2) - 1,
		
	MODBUS_CODE_BLOCK_FIRST,
	MODBUS_CODE_BLOCK_LAST = MODBUS_CODE_BLOCK_FIRST + MAX_PRGS * (CODE_ELEMENT * MAX_CODE / 2) - 1,
	
	MODBUS_WR_TIME_FIRST, 
	MODBUS_WR_TIME_LAST = MODBUS_WR_TIME_FIRST + MAX_WR * ((sizeof(Wr_one_day) * MAX_SCHEDULES_PER_WEEK + 1) / 2) - 1,

	MODBUS_AR_TIME_FIRST, 
	MODBUS_AR_TIME_LAST = MODBUS_AR_TIME_FIRST + MAX_AR * (AR_DATES_SIZE / 2) - 1,

	MODBUS_USER_BLOCK_LAST = MODBUS_AR_TIME_LAST,
//	MODBUS_WR_FIRST, 
//	MODBUS_WR_LAST = MODBUS_WR_FIRST + MAX_WR * sizeof(Str_weekly_routine_point),
//
//	MODBUS_AR_FIRST, 
//	MODBUS_AR_LAST = MODBUS_AR_FIRST + MAX_AR * sizeof(Str_annual_routine_point),
//
//	
//	MODBUS_SUB_INFO_FIRST = 18000,
//	MODBUS_SUB_INFO_LAST = MODBUS_SUB_INFO_FIRST + SUB_NO * Tst_reg_num,

	MODBUS_TASK_TEST = 40000,// 15 * 6
}E_MODBUS; 




#endif
